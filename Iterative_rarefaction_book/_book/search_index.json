[["01-Iterative_rarefaction_intro.html", "Iterative rarefaction Chapter 1 Introduction Table of contents", " Iterative rarefaction Matthew R. Gemmell 2024-07-11 Chapter 1 Introduction ADD NEW COURSE LOGO This book explains and demonstrates how to carry out iterative rarefaction for alpha and beta diversity analysis in R with the phyloseq object. This involves running multiple rounds/iterations of rarefaction and producing and averaged table of alpha and beta diversity values. This is a more robust method than only carrying out one round of rarefaction. Table of contents ADD TABLE OF CONTENTS This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. "],["02-Background.html", "Chapter 2 Iterative rarefaction background 2.1 Should you rarefy? 2.2 Using iterations 2.3 Section contents", " Chapter 2 Iterative rarefaction background Rarefaction is the process of randomly subsetting samples so the total count values are identical across all samples. Rarefaction is intended to correct for bias caused by varying sampling depths across the samples to be analysed. 2.1 Should you rarefy? Rarefaction can be a hotly debated topic with two main points of view. Some researchers believe it is not appropriate. This is backed up by the 2014 paper \"Waste Not, Want Not: Why Rarefying Microbiome Data Is Inadmissible\" Various R package developers do not recommend it such as the developers of phyloseq &amp; microbiome. Some researchers believe it is appropriate. This is backed up by the 2022 paper \"To rarefy or not to rarefy: robustness and efficiency trade-offs of rarefying microbiome data\" The QIIME2 developers include rarefaction in their tutorials/SOPs for alpha and beta diversity analysis We use rarefaction in our analyses but it is ultimately up to you whether you utilise it or not. 2.2 Using iterations In our initial R community analysis workshop we only rarefy once for each sample. In this section we will rarefy multiple times to calculate average values for alpha and beta diversity metrics. This is iterative rarefaction analysis. This iterative approach will, in theory, smooth out any extreme results one round of rarefaction may cause. Extreme results are possibly due the random nature of rarefaction. These extreme results can include: Leaving important features (ASVs, taxonomic groups, etc.) with no counts Causing a few features to have much higher relative abundances Varying alpha and beta diversity values with different sets of rarefaction 2.3 Section contents In this section we will learn how to: Use random seeds for sampling Carry out iterative rarefaction with sets of random seeds Use iterative rarefaction to carry out alpha diversity analysis Use iterative rarefaction to carry out beta diversity analysis "],["03-Setup.html", "Chapter 3 Setup", " Chapter 3 Setup Include info on directory, copying data, and environment setup "],["04-Random_seeds.html", "Chapter 4 Random seeds and sampling 4.1 Random seed notebook 4.2 Random sampling 4.3 Sampling with replacement", " Chapter 4 Random seeds and sampling What are random seeds? Random seeds are numbers that computational tasks use to determine how they will carry out a random task. In this chapter we will demonstrate the use of random seeds. This is to help understand what they are and why they are used. We won't do anything of value with the results in this chapter, instead this knowledge will be useful for understanding iterative rarefaction. 4.1 Random seed notebook Create a new R jupyter-notebook called \"Random_seeds.ipynb\". We will use this for this chapter. 4.2 Random sampling To demonstrate the use of random seed we will use the R function sample(). This function randomly samples a set of numbers. Create the below code in a code cell. #Create a vector containing the numbers 0 to 10 num_vec &lt;- 0:10 #Randomly sample 5 of these numbers sample(x = num_vec, size = 5) If you run the code you will get five random single digit numbers. Run this multiple times and you will hopefully see the sampled numbers are different every time. 4.3 Sampling with replacement You may also notice that within each sample there are no repeating numbers. You can change this by adding the option replace = TRUE. Try this out in a new cell. #Randomly sample 5 of these numbers with replacement sample(x = num_vec, size = 5, replace = TRUE) Run this a few times and you will hopefully notice that the five numbers are not always unique. When sampling with replacement you replace any results back into the sampling pool. When sampling without replacement you don't replace any results back into the sampling pool. The famous example is sampling green and yellow balls from a bag. If you had a bag with 1000 balls and you wanted a rough idea of the ratio of yellow and green balls you could count the number of these balls within a sample of only 50. Without replacement you would take out a ball, record its colour and throw it in a separate container. With replacement you would take out a ball, record its colour and put it back into the initial bag, meaning it could possibly be recounted. One advantage of sampling with replacement is that your sampling size can be larger than your actual population size. For example, you could create a random sampling of 50 with a bag containing 10 balls with replacement. This would not work without replacement. The below script will cause R to produce an error saying it can be done with replacement. #Randomly sample 5 of these numbers with replacement sample(x = num_vec, size = 5, replace = TRUE) Importantly for us rarefaction uses sampling without replacement. Any samples with a lower depth than the rarefaction size will be removed and not be in the resulting rarefied data. "],["05-R_and_random_seeds.html", "Chapter 5 R and random seeds 5.1 Setting the R seed 5.2 Reset seed", " Chapter 5 R and random seeds Sampling is meant to be random but true randomness is pretty much impossible, especially in computing. Therefore, many programs use seeds to determine how random tasks will be carried out. Various programs that use random seeds include: Sampling tools such as sample() and rarefaction Creating bootstrapped phylogenies Creating procedural content such as building Minecraft worlds 5.1 Setting the R seed To carry out random processes R uses a global variable called seed. The seed is normally random and changed every time it is used. This is useful for everyday analysis but what if you want replicable results? In R we can set the seed with the function seet.seed(). Carry this out followed by sampling. #Set random seed set.seed(1234) #Randomly sample 12 of these numbers without replacement sample(x = num_vec, size = 12, replace = FALSE) #Reset random seed (covered later) set.seed(NULL) You will get a result of \"9, 5, 4, 3, &amp; 6\". You can try to run the code multiple times and you will always get the same results. If you run a tool that uses random sampling you will always get the same results if: You use the same random seed (seed for R) You use the same data You use the same parameters including the replacement method (with or without) In fact, run the below code in a new code cell and you may notice a similarity with your previous output. #Set random seed set.seed(1234) #Create a vector containing the numbers 0 to 10 larger_num_vec &lt;- 10:19 #Randomly sample 5 of these numbers sample(x = num_vec, size = 5) #Reset random seed (covered later) set.seed(NULL) That's right, sample() will always take the 10th (9/19), 6th (5/15), 5th (4/14), 4th (3/13), and 7th (6/16) values if it is given the random seed of 1234, provided with an 11 length vector, and asked to sample 5 values. Setting our randomness is incredible beneficial for reproducibility in research. When you carry out analysis you may need to redo some work. This could be due to reviewer comments or you want to incorporate some new methods. As long as you saved the random seeds you used you can get the same results where you need to. It also means others can replicate your results. 5.2 Reset seed We set a random seed at the start of the cell for reproducibility and control, but why do we then run the line set.seed(NULL)? The normal operation of R means that, in effect, its random seed changes every time it is used. This means R normally randomly determines randomness. This is how it should be until we want to set the randomness. It is therefore good practice to set the seed to NULL after you have utilised your set seeds. This will revert the seed to its normal random operations. One last point to note is R versions. Version 3.6 changed R's sampling methods, therefore if you use Version 3.5 or below you will get different results than we have got. Hopefully the R developers will not change this in a later version again. "],["06-Random_seeds_practice.html", "Chapter 6 Random seed practice 6.1 RSQ1 6.2 RSQ2 6.3 RSQ3 6.4 Random seed recap", " Chapter 6 Random seed practice Brilliant! To reinforce the above knowledge try out the following challenges. First create the following vector: second_millenium &lt;- 1001:2000 Note: Remember it is best practice to set.seed(NULL) at the end of a code cell. 6.1 RSQ1 Sample the object second_millenium with the following parameters: Extract 10 values Without replacement Use the random seed 489 What is the fourth number in the produced vector? 1120 1369 1744 RSQ1 code solution #RSQ1 #Set random seed set.seed(489) #Randomly sample first_answer &lt;- sample(x = second_millenium, size = 10)[4] first_answer #Reset random seed set.seed(NULL) 6.2 RSQ2 Sample the object second_millenium with the following parameters: Extract 24 values Without replacement Use the answer to the first question as the random seed What is the 16th number in the produced vector? 1120 1369 1744 RSQ1 code solution #RSQ2 #Set random seed set.seed(first_answer) #Randomly sample second_answer &lt;- sample(x = second_millenium, size = 24)[16] second_answer #Reset random seed set.seed(NULL) 6.3 RSQ3 Sample the object second_millenium with the following parameters: Extract a number of values equal to the answer of the second question With replacement Use the answer to the first question as the random seed What is the 999th number in the produced vector? 1120 1369 1744 RSQ3 code solution #RSQ3 #Set random seed set.seed(first_answer) #Randomly sample sample(x = second_millenium, size = second_answer, replace = TRUE)[999] #Reset random seed set.seed(NULL) 6.4 Random seed recap Once you are happy you can save then close and halt your \"Random_seeds.ipynb\" notebook. Through this section you have learnt: The use of random seeds for random processes such as sampling The difference between sampling with and without replacement How to set random seeds in R for reproducible randomness With this you can continue onto iterative rarefaction. "],["07-Iterating_rarefaction_intro.html", "Chapter 7 Iterating rarefaction intro &amp; setup 7.1 Iterating rarefaction dataset 7.2 Iterating rarefaction setup 7.3 Rarefaction iterations 7.4 RNG vector creation", " Chapter 7 Iterating rarefaction intro &amp; setup In this section we will create code to carry out iterative rarefaction. We'll create a vector of random seeds, each used for a different iteration of rarefaction. We use this vector to loop through, using each random seed to carry out one iteration of rarefaction. In the next sections we will utilise this code to produce alpha and beta diversity values that we will analyse. 7.1 Iterating rarefaction dataset The data set we will use is the same as that used in the R community analysis workshop. Below are brief bullet points about the data: It is a 16S dataset of ASV counts with taxonomy and phylogeny produced by QIIME2 The samples come from surface water from the Durance River in the south-east of France There are three sampling sites on an anthropisation gradient (low to high agriculture) Upper Durance (UD) Middle Durance (MD) Lower Durance (LD) Four different media approaches were used to produce bacterial lawns that were sequenced Environmental sample (ENV): No media used, frozen at -20°C. TSA 10% incubated at 28°C for 2 days. KBC incubated at 28°C for 2 days. CVP incubated at 28°C for 3 days. There are three replicates for each sampling site and media combination (36 samples total) 7.2 Iterating rarefaction setup First, create a new R jupyter-notebook called \"Iterating_rarefaction.ipynb\". At the top of this notebook create a code cell to load in the various packages and data we need. The code is below: #Libraries library(&quot;phyloseq&quot;) library(&quot;microbiome&quot;) library(&quot;IRdisplay&quot;) #Load processed but unrarefied data from R community analysis workshop load(&quot;phyloseq.RData&quot;) 7.3 Rarefaction iterations We need to choose the number of iterations we are going to carry out. For our practice we will use 10 iterations for speed. In your real analysis I would recommend using 1000 iterations. Let's create a variable for our number of iterations. #Number of rarefaction iterations to be carried out #Using 10 here for speed, real analysis should use 1000 rarefaction_iters &lt;- 10 7.4 RNG vector creation We can now carry out Random Number Generation (RNG) to create a number of random seeds equal to the number of iterations planned. #Create rngseed vector #Set seed for reproducibility #This number was chosen randomly set.seed(2605) #Sample 10 (number of iters) values from the number range 1-100,000 rngseed_vec &lt;- sample(x=1:100000, size = rarefaction_iters, replace = FALSE) #Print out vector rngseed_vec #Save our rngseed vector save(rngseed_vec, file=&quot;rngseeds.RData&quot;) #Reset seed set.seed(NULL) There are a lot of steps above. These are: Setting the random seed: We carry this out so we will always get the same rngseed vector that will be used for the rarefaction iterations. This is important so you will always get the same results if you need to rework some analysis, stats, or plots. Also useful here so you get the same results as the instructor and other attendees. Creating the rngseed vector: We use our old friend sample() to create a random number for each iteration we will carry out. We arbitrarily sample from the numbers 1-100,000, you could change this to a larger range in your future research. We use our previous object rarefaction_iters as size= to produce a random number for each of our iterations. We carry this out without replacement so none of our rarefaction iterations are identical. Save the rngseed vector: We save the vector as a file. We will load this in our alpha and beta diversity notebooks to be used for iterative rarefaction. This is also useful so you have a backup file of the rngseed vectors. Reset seed: Always good to reset the seed at the end of a Jupyter notebook cell or after it has been used in a Rscript. "],["08-Phyla_relative_abundance.html", "Chapter 8 Phyla relative abundance 8.1 Subset and phyla aggregation 8.2 Phyla relative abundance bar chart", " Chapter 8 Phyla relative abundance Prior to iterative rarefaction we will look at the phyla composition of the environmental samples. 8.1 Subset and phyla aggregation For demonstrative purposes we will reduce the amount of samples and features in our data for this section. We will carry this out by: Subsetting the data so it only contains the 9 environmental samples. Aggregate the taxa to phyla whilst aggregating rare taxa to one \"other group\" #Reduce data for demonstrative purposes #Subset phyloseq object to only retain the ENV samples #I.e. remove the media samples physeq_env &lt;- phyloseq::subset_samples(pseq, media == &quot;ENV&quot;) #Aggregate to phyla level whilst aggregating rare phyla pseq_env_phyla &lt;- microbiome::aggregate_rare( pseq_env, level = &quot;Phylum&quot;, detection = 0.1, prevalence = 0.5, #Prevent info on aggregation to be printed out verbose = FALSE) #View count table otu_table(pseq_env_phyla) #Sum count of samples microbiome::readcount(pseq_env_phyla) #Remove unwanted objects rm(pseq, pseq_env) 8.2 Phyla relative abundance bar chart Let's have a quick look at the non rarefied phyla relative abundance through a bar chart. Note: This is how you would normally look at this type of bar chart. #Quick phyla bar chart of relative abundance #Relative abundance transformation pseq_env_phyla_relabund &lt;- microbiome::transform(pseq_env_phyla, &quot;compositional&quot;) #Create, save, and display bar chart phylum_bar &lt;- microbiome::plot_composition(pseq_env_phyla_relabund) ggsave(filename = &quot;./env_phyla_relabund.png&quot;, plot = phylum_bar, device = &quot;png&quot;, dpi = 300, units = &quot;mm&quot;, height = 100, width = 100) IRdisplay::display_png(file = &quot;./env_phyla_relabund.png&quot;) "],["09-One_round_of_rarefaction.html", "Chapter 9 One Round (1R) of rarefaction 9.1 1R: Rarefaction 9.2 1R: Relative abundance bar chart 9.3 1R: Difference from non-rarefied", " Chapter 9 One Round (1R) of rarefaction Building up to multiple iterations of rarefaction we will first carry out one round of rarefaction on our environmental pPhyla relative abundance data. This will also allow us to compare the compare the results of no rarefaction to only one round. 9.1 1R: Rarefaction Carry out one round of rarefaction and view the rarefied counts. We are using the environmental samples subsetted and phyla aggregated data. Additionally, we are using the first of our random seeds in rng_seed_vec and the minimum read count as our rarefaction size. #One round of rarefaction pseq_env_phyla_rarefy_1 &lt;- phyloseq::rarefy_even_depth( pseq_env_phyla, #Minimum read count as rarefaction size sample.size = min(microbiome::readcount(pseq_env_phyla)), #First random seed as the rng seed rngseed = rngseed_vec[1]) #View count table otu_table(pseq_env_phyla_rarefy_1) #Sum count of samples microbiome::readcount(pseq_env_phyla_rarefy_1) You should see that all the samples now have a total count of 11046. 9.2 1R: Relative abundance bar chart Now to create a relative abundance bar chart with our rarefied data to compare to our non-rarefied data. Note: This is not something you would do in real analysis. #Quick phyla bar chart of relative abundance #Relative abundance transformation pseq_env_phyla_rarefy_1_relabund &lt;- microbiome::transform(pseq_env_phyla_rarefy_1, &quot;compositional&quot;) #Create, save, and display bar chart phylum_bar &lt;- microbiome::plot_composition(pseq_env_phyla_rarefy_1_relabund) ggsave(filename = &quot;./env_phyla_rarefy_1_relabund.png&quot;, plot = phylum_bar, device = &quot;png&quot;, dpi = 300, units = &quot;mm&quot;, height = 100, width = 100) IRdisplay::display_png(file = &quot;./env_phyla_rarefy_1_relabund.png&quot;) Viewing the non-rarefied and rarefied based bar charts shows some differences. However, these are quite difficult to discern. 9.3 1R: Difference from non-rarefied To more easily see the differences we will subtract the two relative abundance tables from each other. This will produce a matrix of differences. #Value difference matrix single_rarefaction_diff &lt;- phyloseq::otu_table(pseq_env_phyla_relabund) - phyloseq::otu_table(pseq_env_phyla_rarefy_1_relabund) single_rarefaction_diff We can see there are differences. To make these differences even clearer let's make a histogram. #Histogram of differences hist(single_rarefaction_diff, main = &quot;Single rarefaction&quot;) What is the range of the differences compared to the non rarefied relative abundance values? -0.0003(-3e-04) to 0.0003(3e-04) -0.003 to 0.003 -0.015 to 0.015 Although these values appear quite small keep in mind we are working with relative abundance values. Each sample has a total relative abundance of 1.00 so a relative abundance value of 0.01 is 1%. Let's see if we can get these differences smaller with multiple rounds of rarefaction. "],["10-Multiple_rounds_of_rarefaction.html", "Chapter 10 Multiple Rarefaction (MR) iterations 10.1 MR: Rarefaction 10.2 Mathematical operators &amp; data frames 10.3 MR: Difference from non-rarefied", " Chapter 10 Multiple Rarefaction (MR) iterations This chapter will demonstrate how to use a loop to carry out multiple rounds of rarefaction. We'll then compare the non-rarefied data to our iteratively rarefied data. 10.1 MR: Rarefaction The below loop creates a relative abundance table created by 10 rounds of iteration. Type the code and read the annotations to understand it. Then run the code. #Iterative rarefaction to produce an average rarefied relative abundance table #Assign rarefaction size rarefaction_size &lt;- min(microbiome::readcount(pseq_env_phyla)) #Load our rng seed vector load(&quot;rngseeds.RData&quot;) #Initalise where we will store the output #In this case we create the first iteration #Carry out first rarefaction pseq_rarefy &lt;- phyloseq::rarefy_even_depth(pseq_env_phyla, sample.size = rarefaction_size #First random seed as the rng seed rngseed = rngseed_vec[1]) #Calculate relative abundance pseq_rarefy_relabund &lt;- microbiome::transform(pseq_rarefy, &quot;compositional&quot;) #Extract relative abundance phyla table as a data frame relabund_phyla_df &lt;- as.data.frame(phyloseq::otu_table(pseq_rarefy_relabund)) #Loop through the next 9 iterations #Add the relabund rarefied values to phyla_table for (i in 2:length(rngseed_vec)){ #Rarefy pseq_rarefy &lt;- phyloseq::rarefy_even_depth(pseq_env_phyla, sample.size = rarefaction_size rngseed = rngseed_vec[i]) #Calculate relative abundance pseq_rarefy_relabund &lt;- microbiome::transform(pseq_rarefy, &quot;compositional&quot;) #Sum values to phyla_table relabund_phyla_df &lt;- relabund_phyla_df + as.data.frame(phyloseq::otu_table(pseq_rarefy_relabund)) } #Average the values of the summed relabund phyla_table relabund_phyla_mean_df &lt;- relabund_phyla_df / length(rngseed_vec) The loop produces a data frame (relabund_phyla_df) that has all the values from the ten rarefied data frames summed in each corresponding cell. The final data frame is then divided by the number of iterations . This produces the final data frame relabund_phyla_mean_df. 10.2 Mathematical operators &amp; data frames Two numeric data frames/matrices can be summed together with + if they have the same dimensions. This can be carried out with any mathematical operator (+,-,*,/, etc.) An example of how this works is below. Note: You don't need to run the below code as the output is displayed. #Matrix 1 mat1 &lt;- matrix(1:9, nrow = 3, ncol = 3) mat1 ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 #Matrix 2 mat2 &lt;- matrix((1:9)*10, nrow = 3, ncol = 3) mat2 ## [,1] [,2] [,3] ## [1,] 10 40 70 ## [2,] 20 50 80 ## [3,] 30 60 90 #Summed matrix mat_sum &lt;- mat1 + mat2 mat_sum ## [,1] [,2] [,3] ## [1,] 11 44 77 ## [2,] 22 55 88 ## [3,] 33 66 99 If you only use one number with a data frame/matrix the operation will act upon each cell in the same manner. You could add 1 to each cell, minus 4 from each cell, etc. Continuing the matrix example, we'll get the average of the 2 data frames by dividins by two (/2). #Mean matrix mat_mean &lt;- mat_sum / 2 mat_mean ## [,1] [,2] [,3] ## [1,] 5.5 22.0 38.5 ## [2,] 11.0 27.5 44.0 ## [3,] 16.5 33.0 49.5 10.3 MR: Difference from non-rarefied We'll skip the bar chart this time and only look at the difference of the values. #Value difference matrix iterative_rarefaction_diff &lt;- as.matrix(phyloseq::otu_table(pseq_env_phyla_relabund) - relabund_phyla_mean_df) iterative_rarefaction_diff #Histogram hist(iterative_rarefaction_diff) What is the range of the differences compared to the non rarefied relative abundance values? -0.0003(-3e-04) to 0.0003(3e-04) -0.003 to 0.003 -0.015 to 0.015 You should notice that the differences are much smaller. This indicates that the structure of the iterative rarefied data is much closer to the non-rarefied data compared to the one round rarefied data. This is what we want. "],["11-Iterating_rarefaction_practice.html", "Chapter 11 Iterating rarefaction practice 11.1 One thousand iteration 11.2 Iterating rarefaction recap", " Chapter 11 Iterating rarefaction practice Superlative! Now that you know how to carry out iterative rarefaction I'll ask you to do it once more for the phyla data. 11.1 One thousand iteration Create a rarefaction averaged phyla relative abundance as we have done above but with 1000 rarefaction iterations. For this task use 153478 as the seed when creating your vector of 1000 rng seeds. Save this vector of rngseeds to a file called \"rngseeds_1000.RData\". Note: The iterative rarefaction step may take a few minutes. After creating the relative abundance matrix determine how different the values are compared to the non-rarefied relative abundance with a histogram. What is the range of the differences compared to the non rarefied relative abundance values? -0.0003(-3e-04) to 0.0003(3e-04) -0.003 to 0.003 -0.015 to 0.015 Please attempt the task yourself before looking at the solution code in the below expandable box. Task solution code #Number of rarefaction iterations to be carried out rarefaction_iters &lt;- 1000 #Create rngseed vector #Set seed for reproducibility set.seed(153478) #Create the rngseed vector #Sample 1000 (number of iters) values from the number range 1-100,000 rngseed_vec &lt;- sample(x=1:100000, size = rarefaction_iters, replace = FALSE) #Save our rngseed vector save(rngseed_vec, file=&quot;rngseeds_1000.RData&quot;) #Reset seed set.seed(NULL) #Iterative rarefaction to produce an average rarefied relative abundance table #Assign rarefaction size rarefaction_size &lt;- min(microbiome::readcount(pseq_env_phyla)) #Read in our rng seed vector load(&quot;rngseeds_1000.RData&quot;) #Initalise where we will store the output #In this case we create the first iteration #Carry out first rarefaction pseq_rarefy &lt;- phyloseq::rarefy_even_depth(pseq_env_phyla, sample.size = rarefaction_size rngseed = rngseed_vec[1]) #Calculate relative abundance pseq_rarefy_relabund &lt;- microbiome::transform(pseq_rarefy, &quot;compositional&quot;) #Relabund phyla table object relabund_phyla_table &lt;- as.data.frame(phyloseq::otu_table(pseq_rarefy_relabund)) #Loop through the next 999 iterations #Add the relabund rarefied values to phyla_table for (i in 2:length(rngseed_vec)){ #Rarefy pseq_rarefy &lt;- phyloseq::rarefy_even_depth(pseq_env_phyla, sample.size = rarefaction_size rngseed = rngseed_vec[i]) #Calculate relative abundance pseq_rarefy_relabund &lt;- microbiome::transform(pseq_rarefy, &quot;compositional&quot;) #Sum values to phyla_table relabund_phyla_table &lt;- relabund_phyla_table + as.data.frame(phyloseq::otu_table(pseq_rarefy_relabund)) } #Average the values of the summed relabund phyla_table relabund_phyla_table &lt;- relabund_phyla_table / length(rngseed_vec) #Value difference matrix iterative_rarefaction_1000_diff &lt;- as.matrix(phyloseq::otu_table(pseq_env_phyla_relabund) - relabund_phyla_table) iterative_rarefaction_diff #Histogram hist(iterative_rarefaction_diff) 11.2 Iterating rarefaction recap With this section you have learnt: How to create a vector of rngseeds How to use rng seeds to carry out iterative rarefaction In you real life analysis you would not use this method to create relative abundance taxonomy bar charts, you would use the non-rarefied relative abundance. However, this hopefully gave you a good idea of how iterative rarefaction works so we can utilise it the next 2 chapters for alpha and beta diversity analysis. Feel free to save then close and halt your \"Iterating_rarefaction.ipynb\" notebook. "]]
