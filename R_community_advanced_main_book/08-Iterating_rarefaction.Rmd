# Iterating rarefaction {#iterating_rarefaction_chap}
<center>
![](figures/random_seeds.png){style="width:200px"}
</center>

In this chapter we will create code to carry out iterative rarefaction.
For this we create a vector of random seeds, each used for a different iteration of rarefaction.
We will loop through these random seeds, using each random seed to carry out one iteration of rarefaction.
In the next chapters we will utilise this code to produce alpha and beta diveristy values that we will analyse.

## Iterating rarefaction dataset
<center>
![](figures/river.png){style="width:200px"}
</center>

We will utilise the same dataset used in the [R community analysis workshop](https://neof-workshops.github.io/R_community_whqkt8/Course/02-Dataset_and_workflow.html#dataset).

Below are brief bullet points about the data:

- It is a 16S dataset of ASV counts with taxonomy and phylogeny produced by QIIME2
- The samples come from surface water from the Durance River in the south-east of France
- There are three sampling site on an anthropisation gradient (low to high agriculture)
  - Upper Durance (UD)
  - Middle Durance (MD)
  - Lower Durance (LD)
- Four different media approaches were used to produce bacterial lawns that were sequenced.
  - Environmental sample (ENV): No media used, frozen at -20째C.
  - TSA 10% incubated at 28째C for 2 days.
  - KBC incubated at 28째C for 2 days.
  - CVP incubated at 28째C for 3 days.

## Iterating rarefaction setup

First, create a new R jupyter-notebook called "Iterating_rarefaction.ipynb".

At the top of this notebook create a code cell to load in the various packages and data we need. The code is below:

```{R, eval=FALSE}
#Libaries

#Data
```

## Rarefaction iterations

We need to choose the number of iterations we are going to carry out.

For our __practice__ we will use __10 iterations__ for speed. 
In your real analysis I would recommend using __1000 iterations__.

Let's create a variable for our number of iterations.

```{R, eval=FALSE}
#Number of rarefaction iterations to be carried out
#Using 10 here for speed, real analysis should use 1000
rarefaction_iters <- 10
```

## RNG vector creation

We can now carry out __Random Number Generation (RNG)__ to create a number of random seeds equal to the number of iterations planned.

```{R, eval=FALSE}
#Create rngseed vector
#Set seed for reproducibility
set.seed(2605)
#Sample 10 (number of iters) values from the number range 1-100,000
rngseed_vec <- sample(x=1:100000, size = rarefaction_iters, replace = FALSE)
#Print out vector
rngseed_vec
#Save our rngseed vector
save(rngseed_vec, file="rngseeds.RData")
#Reset seed
set.seed(NULL)
```

There are a lot of steps above. These are:

- __Setting the random seed:__ We carry this out so we will always get the same rngseed vector that will be used for the rarefaction iterations. This is important so you will always get the same results if you need to rework some analysis, stats, or plots. ALso useful here so you get the same results as the instructor and other attendees.
- __Creating the rngseed vector:__ We use our old friend `sample()` to create a random number for each iteration we will carry out. 
  - We arbitrarily sample from the numbers 1-100,000, you could change this to a larger range in your future research.
  - We use our previous object `rarefaction_iters` as `size=` to produce a random number for each of our iterations.
  - We carry this out without replacement so none of our rarefaction iterations are identical.
- __Save the rngseed vector:__ We save the vector as a file. We will load this in our alpha and beta diversity notebooks to be used for iterative rarefaction. This is also useful so you have a backup file of the rngseed vectors. 
- __Reset seed:__ Always good to reset the seed at the end of a cell.

## Random sampling
<center>
![](figures/random_sampling.png){style="width:200px; background:white; border-radius:5px"}
</center>

To demonstrate this we will use the R function `sample()`. 
This function randomly samples a set of numbers.

Create the below code in a code cell.

```{R, eval=FALSE}
#Create a vector containing the numbers 0 to 10
num_vec <- 0:10
#Randomly sample 5 of these numbers
sample(x = num_vec, size = 5)
```

If you run the code you will get five random single digit numbers.

Run this multiple times and you will hopefully see the sampled numbers are different every time.

## Sampling with replacement
<center>
![](figures/balls.png){style="width:200px"}
</center>

You may also notice that within each sample there are no repeating numbers.
You can change this by adding the options `replace = TRUE`.

Try this out in a new cell.

```{R, eval=FALSE}
#Randomly sample 5 of these numbers with replacement
sample(x = num_vec, size = 5, replace = TRUE)
```

Run this a few times and you will hopefully notice that there are repeats.

When sampling with replacement you put back any results back into the sampling pool.
When sampling without replacement you don't put back any results into the sampling pool.

The famous example is sampling green and yellow balls from a bag.
If you had a bag with 1000 balls and you wanted a rough idea of the ratio of yellow and green balls you could count the number of these balls of only 50.
Without replacement you would take out a ball, mark its colour and throw it in a separate container.
With replacement you would take out a ball, mark its colour and put it back into the intial bag, meanig it could possibly be recounted.

One advantage of sampling with replacement is that your sampling size can be larger than your actual population size.
For example, you could create a random sampling of 50 with a bag containing 10 balls with replacement.
This would not work without replacement.
The below script will cause R to produce an error saying it can be done with replacement.

```{R, eval=FALSE}
#Randomly sample 5 of these numbers with replacement
sample(x = num_vec, size = 5, replace = TRUE)
```

Importantly for us rarefaction uses sampling without replacement.

## Setting a random seed
<center>
![](figures/set_a_seed.png){style="width:400px"}
</center>

We'll sample, without replacement, the numbers one more time in a new cell.
However, this time we will set the random seed with the function `seet.seed()`.

```{R, eval=FALSE}
#Set random seed
set.seed(1234)
#Randomly sample 12 of these numbers without replacement
sample(x = num_vec, size = 12, replace = FALSE)
#Reset random seed
set.seed(NULL)
```

Before we explain the code further, try running the cell multiple times.
If it is identical to the above code you will get the numbers "9, 5, 4, 3, & 6".

How come you are getting these results if it is random?

True randomness is pretty much impossible, especially in computing.
To get around this many programs use seeds to determine how random tasks will be carried out.
Various programs that use random seeds include:

- Sampling tools such as `sample()` and rarefaction
- Creating bootstrapped phylogenies
- Creating procedural content such as building Minecraft worlds

Therefore if you run a tool that will use randomness you will always get the same results if:

- You use the same random seed
- You use the same data
- You use the same replacement method (with or without)

In fact, run the below code in a new code cell and you may notice a similarity with your previous output.

```{R, eval=FALSE}
#Set random seed
set.seed(1234)
#Create a vector containing the numbers 0 to 10
larger_num_vec <- 10:19
#Randomly sample 5 of these numbers
sample(x = num_vec, size = 5)
#Reset random seed
set.seed(NULL)
```

That's right, `sample()` will always take the 10th (9/19), 6th (5/15), 5th (4/14), 4th (3/13), and 7th (6/16) values if it is given the random seed of (1234) and provided with a 11 length vector.

Setting our randomness is incredible beneficial for reproducibility in research.

When you carry out analysis you may need to redo some work. 
This could be due to reviewer comments or you want to incorporate some new methods.
As long as you saved the random seeds you used you can get the same results where you need to.
It also means others can replicate your results.

## Reset seed
<center>
![](figures/reset_seed.png){style="width:400px"}
</center>

We set a random seed at the start of the cell for reproducibility and control, but why do we then run the line `set.seed(NULL)`?

The normal operation of R means that, in effect, its random seed changes every time it is used.
This means R normally randomly determines randomness.
This is how it should be until we want to set the randomness.
It is therefore good practice to set the seed to `NULL` after you have utilised your set seeds.
This will revert the seed to its normal random operations.

One last point to note is R versions. 
Version 3.6 changed R's sampling methods, therefore if you use Version 3.5 or below you will get different results than we have got.
Hopefully the R developers will not change this in a later version again.

## Random seed practice
<center>
![](figures/seed_sowing.png){style="width:200px"}
</center>

Brilliant! To reinforce the above knowledge try out the following challenges.

First create the following vector:

```{R, eval=FALSE}
second_millenium <- 1001:2000
```

__Note:__ Remember it is best practice to `set.seed(NULL)` at the end of a code cell.

### Random seed: Question 1

Sample the object `second_millenium` with the following parameters:

- Extract 10 values
- Without replacement
- Use the random seed `489`

```{r, echo = FALSE}
opts_p <- c("__1120__", answer="__1369__", "__1744__")
```
What is the fourth number in the produced vector? `r longmcq(opts_p)`

### Random seed: Question 2

Sample the object `second_millenium` with the following parameters:

- Extract 24 values
- Without replacement
- Use the answer to the first question as the random seed

```{r, echo = FALSE}
opts_p <- c("__1120__", "__1369__", answer="__1744__")
```
What is the 16th number in the produced vector? `r longmcq(opts_p)`

### Random seed: Question 3

Sample the object `second_millenium` with the following parameters:

- Extract a number of values equal to the answer of the second question
- With replacement
- Use the answer to the first question as the random seed

```{r, echo = FALSE}
opts_p <- c(answer="__1120__", "__1369__", "__1744__")
```
What is the 999th number in the produced vector? `r longmcq(opts_p)`

Once you are happy you can save then close and halt your "Random_seeds.ipynb" notebook.

Hopefully this has given you a good undertstanding of the principle of random seeds. With this you can continue onto iterative rarefaction.