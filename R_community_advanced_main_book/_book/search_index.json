[["01-R_community_advanced_main_book.html", "R community advanced analysis Chapter 1 Introduction Table of contents", " R community advanced analysis Matthew R. Gemmell 2024-06-13 Chapter 1 Introduction ADD NEW COURSE LOGO ADD NEW COURSE INTRO Table of contents ADD TABLE OF CONTENTS This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. "],["02-Dataset_and_workflow.html", "Chapter 2 Dataset &amp; workflow 2.1 Dataset 2.2 Workflow", " Chapter 2 Dataset &amp; workflow 2.1 Dataset In this tutorial we will be using a 16S metabarcoding dataset derived from surface water from the Durance River in the south-east of France. Two major comparisons were carried out in combination with each other. Link to paper 2.1.1 Sites Three different sites were chosen on the Durance River. These three sites were representative of an anthropisation (transformation of land by humans) gradient along a river stream. These sites were: Upper Durance sampling site (UD): Alpine part of the river with little/no anthropisation. Middle Durance sampling site (MD): Upper part of agricultural land dominated by apple and pear production. Lower Durance sampling site (LD): Lower part of agricultural land with intensive production of fruits, cereals, and vegetables. 2.1.2 Culture media Surface water was sampled and different culture media were used to produce bacterial lawns for each site. The media used were: Environmental sample (ENV): No media used, frozen at -20°C. TSA 10% incubated at 28°C for 2 days. KBC incubated at 28°C for 2 days. CVP incubated at 28°C for 3 days. 2.1.3 Summary &amp; questions Each sample and media combination was produced in replicates of three giving a total of 36 samples (3 X 4 X 3 = 36). The three replicates were cultured on three different plates with the same media. An ASV table, taxonomy table, and phylogenetic tree were produced with QIIME2 and DADA2. With this data we can ask and investigate the following questions: How do the bacterial communities change across the anthropisation gradient? Is there a difference in the replicates of one site and media combination? I.e. do any of the media produce inconsistent profiles? Is there more difference between the sites or the media used? Do the media samples differ from the ENV samples? If so, how? 2.2 Workflow Import: Import QIIME2 artifacts into a phyloseq object with qiime2R. Summarisations: Check our phyloseq object with summarisations. Minimum depth: Determine the minimum depth we should use and remove samples with lower depth. Taxanomic relative abundance: Create taxonomic relative abundance tables. Taxa plots: Produce heat maps and bar plots of taxa relative abundances. Family and genus: Using the last step to produce family and genus based taxa plots. Rarefaction: Carry out sample depth normalisation with rarefactions. This will be used for alpha and beta diversity analysis. Alpha diversity: Carry out alpha diversity analysis through plots and statistics. Beta diversity: Carry out beta diversity analysis through plots and statistics. Differenital abundance anlaysis: Detect biomarkers compared to a reference group with ANCOM. "],["03-R_packages.html", "Chapter 3 R Packages 3.1 R packages/libraries 3.2 The grammar of graphics 3.3 phyloseq", " Chapter 3 R Packages During this workshop we will use various R packages with their own intricacies. Before going into analysis we'll introduce you to some of these important concepts. 3.1 R packages/libraries R packages/libraries contain additional functions, data and code for analysing, manipulating and plotting different types of data. Many common packages will be installed as default when you install R. Other more specialised packages, such as the ggplot2 package, must be installed by the user. Packages found on The Comprehensive R Archive Network (CRAN), R’s central software repository, can be installed using the following command. install.packages(&quot;package_name&quot;) Every time you reload R you will need to load the packages you require if they are not installed in R by default. To do this type: library(&quot;package_name&quot;) I generally have a list of library() functions at the top of my R scripts (.R files) for all the packages I use in the script. Throughout this course you will get a lot of practice installing and loading various packages. R package or R Library? R packages are a collection of R functions, data, and compiled code. You can install these into a directory on your computer. An R library is a directory containing a R package. Because of this, the terms R package and R library may be used synonymously. We will use the term package in this workshop. As we will be using a lot of packages we shall use double colons (::) to specify which package each function belongs to, unless the function is from base R. For example if we use the function summarize_phyloseq() from the package microbiome we would type the function like below: Note: Do not run the below command. microbiome::summarize_phyloseq() This convention has 2 benefits: We can easily tell which R package each function comes from. This is useful for your future coding where you may copy some, but not all, commands from one script to another. You will therefore know which packages you will need to load. If you need some more documentation about a function you will know what package to look up. Writing your methods will be a lot easier. Different packages may have functions with the same name. Specifying the package will ensure you are using the correct function. 3.2 The grammar of graphics During this course we will be using the grammar of graphics coding approach. This approach is implemented by the R package ggplot2 to create visualisations such as bar charts, box plots, ordination plots etc. In turn ggplot2 is used by a host of other packages, some of which we will be using. Although ggplot2 is R code, its structure is very different and it takes effort to learn. Thankfully, ggplot2 is very powerful and flexible, and it produces very professional and clean plots. We will use the iris dataset (inbuilt into R) to show an example of ggplot2 code and its visualisation output. You don't need to run the below code. Note: If you would like to see the contents of the iris dataset you can run the command View(iris) in your R instance later. #Load library library(ggplot2) #Create new ggplot2 object using iris dataset ggplot2::ggplot(iris, aes(x=Sepal.Length, y=Sepal.Width, colour=Species)) + #Make the object a scatter plot ggplot2::geom_point() + #Add plot tile ggplot2::ggtitle(&quot;Iris Sepal length vs width&quot;) + #Set x and y axis label names ggplot2::labs(x = &quot;Sepal length&quot;, y = &quot;Sepal width&quot;) We will not learn ggplot2 specifically during this course. However, the structure of creating an object will be used. In the above case the initial object was built with ggplot. Subsequently additions and edits were carried out with + and various other functions. An important concept of the grammar of graphics is aesthetics. Aesthetics are the parts of a graphic/plot. In the above command we set the aesthetics with the function aes() within the ggplot() function. The X aesthetic (i.e. what values are assigned to the x axis) was set as the Sepal length values from the column Sepal.Length of the dataframe iris. In turn the Y axis values are set to the Sepal width and the colouring of the points are set to the Species. That was a quick introduction to the grammar of graphics. We will be using this to create visualisations with a phyloseq object using various R packages specifically designed for community abundance data within phyloseq objects. For more resources on ggplot2 please see the appendix of this book. 3.3 phyloseq In this book we will be working with phyloseq objects to preprocess our dataset, create visualisations, and carry out statistical analyses. This is a very popular object type for community abundance datasets as it contains the abundance table, metadata, and taxonomy table in one object, optionally containing the phylogenetic tree and reference sequences if wanted/required. For more info on phyloseq and associated packages please see the appendix. "],["04-Setup.html", "Chapter 4 Set-up 4.1 Logon instructions 4.2 Mamba", " Chapter 4 Set-up Prior to any analysis we need to setup our environment in the webVNC. 4.1 Logon instructions For this workshop we will be using Virtual Network Computing (VNC). Connect to the VNC with a browser by using the webVNC link you were sent. You will now be in a logged-in Linux VNC desktop. You will see something as below (there may be only one terminal which is fine). If you do not see something similar please ask for assistance. If the VNC is taking up too much/little space of your browser you can use the zoom of your browser to adjust the size. You will most likely need to use your browser's tool bar to accomplish this. Ensure you can see the grey borders. These instructions will not work outside of this workshop. If you would like to install your own Linux OS on your desktop or laptop we would recommend Mint Linux The following link is a guide to install Mint Linux: https://linuxmint-installation-guide.readthedocs.io/en/latest/ 4.2 Mamba This workshop requires a lot of packages. These all can be difficult to install with R. Instead we have used Mamba forge to install R, its packages, and Jupyter-notebook (more info below). To learn more about Mamba-forge and how to create your own environment please see the appendix. To set-up your environment for this workshop please run the following code (you must include the full stop and space at the front of the command). . usercommunity You will have successfully activated the environment if you now see (r_community) at the start of your command prompt. This indicates you are now in the mamba environment called r_community created by the instructor. If you are interested in the use script you can look at its contents. less /usr/local/bin/usercommunity Tip: press q to quit less. For more about mamba and how to create your own r_community environment please see the appendix "],["05-Jupyter.html", "Chapter 5 Jupyter 5.1 Open Jupyter-notebook 5.2 Create R notebook 5.3 Cells and code 5.4 Create new cells 5.5 Running code 5.6 Saving the file 5.7 Title cells with markdown 5.8 Close the notebook 5.9 Video tutorial", " Chapter 5 Jupyter Jupyter-notebook is a nice browser based method to write, edit, and run code. It was initally created for Python coding, but has since branched out to many other languages, such as R. We are using it in this workshop for a variety of its properties: It is popular and well maintained. It is lightweight. Other heavier weight programs, such as RStudio, would struggle in our HPC due to the graphical and CPU load. It is interactive and displays code output. It allows for easier annotation, editing, and debugging than the command line. It provides a graphical interface for changing directories and choosing files. Before carrying out any analysis we will go through a quick tutorial of jupyter-notebook. Note: There is a video tutorial of this chapter at the bottom of this page if you prefer to watch it. 5.1 Open Jupyter-notebook The first step is to open jupyter-notebook. Run the below command in your (r_community) environment. jupyter-notebook This will open jupyter-notebook in firefox. We won't need to access the linux terminal anymore. Leave the terminal running jupyter-notebook and full screen your firefox so you should see something like below. Can't see the whole webVNC window? You may need to zoom out with your browser so you can see the full webVNC window. Chrome: Click on the three dots in vertical line ( ) on the top left for a dropdown menu which includes zoom options. Edge: Click on the three horizontal lines ( ) on the top left for a dropdown menu which includes zoom options. Firefox: Click on the three dots in horizontal line ( ) on the top left for a dropdown menu which includes zoom options. 5.2 Create R notebook The next step is to create an R notebook. Click on the \"New\" button towards the top right, right of the \"Upload\" button. From the dropdown click \"R\" below \"Python 3 (ipykernel)\". This will open up a new R notebook like below. 5.3 Cells and code Jupyter-notebook uses cells (the grey boxes) to separate code. This is very useful to compartmentalise our code. There will already be one cell. Within the cell, type in the below commands. 1+1 2-3 When pressing enter in cells it will create a new line. To run all commands in a cell press CTRL + enter. Run your current cell and you should see something like below. 5.4 Create new cells You can create new cells by 2 different means. Press the + button on the tool bar (between the floppy disk and scissors ). This will add a cell below your currently selected cell. Click on the Insert button and use the dropdown to add a cell above or below your currently selected cell. Tip: Hover over the toolbar icons to display a text based description of its function. With that knowledge add a second cell below the first cell. Add the following code to your second cell but do not run it. num_1 &lt;- 3 num_2 &lt;- 10 Tip: Notice there are green lines around your selected cell. Insert a third cell and add the following code to it. Do not run the code. num_1 * num_2 5.5 Running code Try to run the code in the third cell. There should be an error as we have not created the objects num_1 &amp; num_2. We have only written the code for these objects but not run them. We can run all the code in a notebook starting from the first cell to the last cell. To run all cells from the start: Click on the \"Cell\" button. Click \"Run All\" from the drop-down options. You should then see something like the below in your notebook. There is no output printed for cell 2 because we are assigning variables. However, the correct output for Cell 3 is below it. This is because the variables were assigned in cell 2 before cell 3 was run. 5.6 Saving the file As with RStudio and other good coding interfaces we can save our notebook. First we should rename the file. Rename the notebook to \"jupyter_tut.ipynb\": Click on the name of the notebook, currently called \"Untitled\". This is at the very top of the notebook, right of the Jupyter logo. A pop-up called \"Rename Notebook\" will appear. Change the Name to \"jupyter_tut.ipynb\". Click \"Rename\". Now we can save the file. Two methods to save are: Click the floppy disk on the toolbar. Click on the \"File\" button. Click \"Save and Checkpoint\" from the dropdown options. 5.7 Title cells with markdown We will be using multiple notebooks in this workshop. We will also have multiple sections per notebook. It will be useful to create header cells with markdown to create visual separation of the different sections. To add a header cell to the top of our notebook: Create a new cell at the top of the notebook. Click on the \"Code\" drop down and select \"Markdown\". The \"Heading\" option no longer works. Add the following to the \"Markdown\" cell to create a first level header. Ensure you have a space between the # and header text (\"Tutorial\"). # Tutorial Great, we can now add nice headers in our notebooks. Save the notebook once more before carrying on to the next section. Markdown You won't need to know more about Markdown but if you are interested please see the Markdown guide. 5.8 Close the notebook To close the notebook: Click on \"File\". From the dropdown options click \"Close and Halt\". When you are back in the file explorer page you may not yet see the new file you saved. If so, you will need to refresh the page with the Refresh button towards the top right. With that quick tutorial of jupyter-notebook we can start our community analysis in the next chapter. For more info on jupter-notebook please see the appendix. 5.9 Video tutorial "],["06-Iterative_rarefaction.html", "Chapter 6 Iterative rarefaction intro 6.1 Should you rarefy? 6.2 Using iterations 6.3 Section contents", " Chapter 6 Iterative rarefaction intro Rarefaction is the process of randomly subsetting samples so the total count values are identical across all samples. Rarefaction is intended to correct for bias caused by varying sampling depths across the samples to be analysed. 6.1 Should you rarefy? Rarefaction can be a hotly debated topic with two main points of view. Some researchers believe it is not appropriate. This is backed up by the 2014 paper \"Waste Not, Want Not: Why Rarefying Microbiome Data Is Inadmissible\" Various R package developers do not recommend it such as the developers of phyloseq &amp; microbiome. Some researchers believe it is appropriate. This is backed up by the 2022 paper \"To rarefy or not to rarefy: robustness and efficiency trade-offs of rarefying microbiome data\" The QIIME2 developers include rarefaction in their tutorials/SOPs for alpha and beta diversity analysis We use rarefaction in our analyses but it is ultimately up to you whether you utilise it or not. 6.2 Using iterations In our initial R community analysis workshop we only rarefy once for each sample. In this section we will rarefy multiple times to calculate average values for alpha and beta diversity metrics. This is an iterative rarefaction analysis. This iterative approach will, in theory, smooth out any extreme results one round of rarefaction may cause, Extreme results being possibly due the random nature of rarefaction. These extreme results can include: Leaving important features (ASVs, taxonomic groups, etc.) with no counts Causing a few features to have much higher relative abundances than Varying alpha and beta diversity values with different sets of rarefaction 6.3 Section contents In this section we will learn how to: Use random seeds for sampling Carry out iterative rarefaction with sets of random seeds Use iterative rarefaction to carry out alpha diversity analysis Use iterative rarefaction to carry out beta diversity analysis "],["07-Rarefaction_and_random_seeds.html", "Chapter 7 Random seeds 7.1 Random seed notebook 7.2 Random sampling 7.3 Sampling with replacement 7.4 Setting a random seed 7.5 Reset seed 7.6 Random seed practice", " Chapter 7 Random seeds What are random seeds? Random seeds are numbers that computational tasks use to determine how they will carry out a random task. In this chapter we will demonstrate the use of random seeds. This is to help understand what they are and why they are used. We won't do anything of value with the results in this chapter, instead this knowledge will be useful for understanding iterative rarefaction. 7.1 Random seed notebook Create a new R jupyter-notebook called \"Random_seeds.ipynb\". We will use this for this chapter. 7.2 Random sampling To demonstrate this we will use the R function sample(). This function randomly samples a set of numbers. Create the below code in a code cell. #Create a vector containing the numbers 0 to 10 num_vec &lt;- 0:10 #Randomly sample 5 of these numbers sample(x = num_vec, size = 5) If you run the code you will get five random single digit numbers. Run this multiple times and you will hopefully see the sampled numbers are different every time. 7.3 Sampling with replacement You may also notice that within each sample there are no repeating numbers. You can change this by adding the options replace = TRUE. Try this out in a new cell. #Randomly sample 5 of these numbers with replacement sample(x = num_vec, size = 5, replace = TRUE) Run this a few times and you will hopefully notice that there are repeats. When sampling with replacement you put back any results back into the sampling pool. When sampling without replacement you don't put back any results into the sampling pool. The famous example is sampling green and yellow balls from a bag. If you had a bag with 1000 balls and you wanted a rough idea of the ratio of yellow and green balls you could count the number of these balls of only 50. Without replacement you would take out a ball, mark its colour and throw it in a separate container. With replacement you would take out a ball, mark its colour and put it back into the intial bag, meanig it could possibly be recounted. One advantage of sampling with replacement is that your sampling size can be larger than your actual population size. For example, you could create a random sampling of 50 with a bag containing 10 balls with replacement. This would not work without replacement. The below script will cause R to produce an error saying it can be done with replacement. #Randomly sample 5 of these numbers with replacement sample(x = num_vec, size = 5, replace = TRUE) Importantly for us rarefaction uses sampling without replacement. 7.4 Setting a random seed We'll sample, without replacement, the numbers one more time in a new cell. However, this time we will set the random seed with the function seet.seed(). #Set random seed set.seed(1234) #Randomly sample 12 of these numbers without replacement sample(x = num_vec, size = 12, replace = FALSE) #Reset random seed set.seed(NULL) Before we explain the code further, try running the cell multiple times. If it is identical to the above code you will get the numbers \"9, 5, 4, 3, &amp; 6\". How come you are getting these results if it is random? True randomness is pretty much impossible, especially in computing. To get around this many programs use seeds to determine how random tasks will be carried out. Various programs that use random seeds include: Sampling tools such as sample() and rarefaction Creating bootstrapped phylogenies Creating procedural content such as building Minecraft worlds Therefore if you run a tool that will use randomness you will always get the same results if: You use the same random seed You use the same data You use the same replacement method (with or without) In fact, run the below code in a new code cell and you may notice a similarity with your previous output. #Set random seed set.seed(1234) #Create a vector containing the numbers 0 to 10 larger_num_vec &lt;- 10:19 #Randomly sample 5 of these numbers sample(x = num_vec, size = 5) #Reset random seed set.seed(NULL) That's right, sample() will always take the 10th (9/19), 6th (5/15), 5th (4/14), 4th (3/13), and 7th (6/16) values if it is given the random seed of (1234) and provided with a 11 length vector. Setting our randomness is incredible beneficial for reproducibility in research. When you carry out analysis you may need to redo some work. This could be due to reviewer comments or you want to incorporate some new methods. As long as you saved the random seeds you used you can get the same results where you need to. It also means others can replicate your results. 7.5 Reset seed We set a random seed at the start of the cell for reproducibility and control, but why do we then run the line set.seed(NULL)? The normal operation of R means that, in effect, its random seed changes every time it is used. This means R normally randomly determines randomness. This is how it should be until we want to set the randomness. It is therefore good practice to set the seed to NULL after you have utilised your set seeds. This will revert the seed to its normal random operations. One last point to note is R versions. Version 3.6 changed R's sampling methods, therefore if you use Version 3.5 or below you will get different results than we have got. Hopefully the R developers will not change this in a later version again. 7.6 Random seed practice Brilliant! To reinforce the above knowledge try out the following challenges. First create the following vector: second_millenium &lt;- 1001:2000 Note: Remember it is best practice to set.seed(NULL) at the end of a code cell. 7.6.1 Random seed: Question 1 Sample the object second_millenium with the following parameters: Extract 10 values Without replacement Use the random seed 489 What is the fourth number in the produced vector? 1120 1369 1744 7.6.2 Random seed: Question 2 Sample the object second_millenium with the following parameters: Extract 24 values Without replacement Use the answer to the first question as the random seed What is the 16th number in the produced vector? 1120 1369 1744 7.6.3 Random seed: Question 3 Sample the object second_millenium with the following parameters: Extract a number of values equal to the answer of the second question With replacement Use the answer to the first question as the random seed What is the 999th number in the produced vector? 1120 1369 1744 Once you are happy you can save then close and halt your \"Random_seeds.ipynb\" notebook. Hopefully this has given you a good undertstanding of the principle of random seeds. With this you can continue onto iterative rarefaction. "],["08-Iterating_rarefaction.html", "Chapter 8 Iterating rarefaction 8.1 Iterating rarefaction dataset 8.2 Iterating rarefaction setup 8.3 Rarefaction iterations 8.4 RNG vector creation 8.5 Random sampling 8.6 Sampling with replacement 8.7 Setting a random seed 8.8 Reset seed 8.9 Random seed practice", " Chapter 8 Iterating rarefaction In this chapter we will create code to carry out iterative rarefaction. For this we create a vector of random seeds, each used for a different iteration of rarefaction. We will loop through these random seeds, using each random seed to carry out one iteration of rarefaction. In the next chapters we will utilise this code to produce alpha and beta diveristy values that we will analyse. 8.1 Iterating rarefaction dataset We will utilise the same dataset used in the R community analysis workshop. Below are brief bullet points about the data: It is a 16S dataset of ASV counts with taxonomy and phylogeny produced by QIIME2 The samples come from surface water from the Durance River in the south-east of France There are three sampling site on an anthropisation gradient (low to high agriculture) Upper Durance (UD) Middle Durance (MD) Lower Durance (LD) Four different media approaches were used to produce bacterial lawns that were sequenced. Environmental sample (ENV): No media used, frozen at -20°C. TSA 10% incubated at 28°C for 2 days. KBC incubated at 28°C for 2 days. CVP incubated at 28°C for 3 days. 8.2 Iterating rarefaction setup First, create a new R jupyter-notebook called \"Iterating_rarefaction.ipynb\". At the top of this notebook create a code cell to load in the various packages and data we need. The code is below: #Libaries #Data 8.3 Rarefaction iterations We need to choose the number of iterations we are going to carry out. For our practice we will use 10 iterations for speed. In your real analysis I would recommend using 1000 iterations. Let's create a variable for our number of iterations. #Number of rarefaction iterations to be carried out #Using 10 here for speed, real analysis should use 1000 rarefaction_iters &lt;- 10 8.4 RNG vector creation We can now carry out Random Number Generation (RNG) to create a number of random seeds equal to the number of iterations planned. #Create rngseed vector #Set seed for reproducibility set.seed(2605) #Sample 10 (number of iters) values from the number range 1-100,000 rngseed_vec &lt;- sample(x=1:100000, size = rarefaction_iters, replace = FALSE) #Print out vector rngseed_vec #Save our rngseed vector save(rngseed_vec, file=&quot;rngseeds.RData&quot;) #Reset seed set.seed(NULL) There are a lot of steps above. These are: Setting the random seed: We carry this out so we will always get the same rngseed vector that will be used for the rarefaction iterations. This is important so you will always get the same results if you need to rework some analysis, stats, or plots. ALso useful here so you get the same results as the instructor and other attendees. Creating the rngseed vector: We use our old friend sample() to create a random number for each iteration we will carry out. We arbitrarily sample from the numbers 1-100,000, you could change this to a larger range in your future research. We use our previous object rarefaction_iters as size= to produce a random number for each of our iterations. We carry this out without replacement so none of our rarefaction iterations are identical. Save the rngseed vector: We save the vector as a file. We will load this in our alpha and beta diversity notebooks to be used for iterative rarefaction. This is also useful so you have a backup file of the rngseed vectors. Reset seed: Always good to reset the seed at the end of a cell. 8.5 Random sampling To demonstrate this we will use the R function sample(). This function randomly samples a set of numbers. Create the below code in a code cell. #Create a vector containing the numbers 0 to 10 num_vec &lt;- 0:10 #Randomly sample 5 of these numbers sample(x = num_vec, size = 5) If you run the code you will get five random single digit numbers. Run this multiple times and you will hopefully see the sampled numbers are different every time. 8.6 Sampling with replacement You may also notice that within each sample there are no repeating numbers. You can change this by adding the options replace = TRUE. Try this out in a new cell. #Randomly sample 5 of these numbers with replacement sample(x = num_vec, size = 5, replace = TRUE) Run this a few times and you will hopefully notice that there are repeats. When sampling with replacement you put back any results back into the sampling pool. When sampling without replacement you don't put back any results into the sampling pool. The famous example is sampling green and yellow balls from a bag. If you had a bag with 1000 balls and you wanted a rough idea of the ratio of yellow and green balls you could count the number of these balls of only 50. Without replacement you would take out a ball, mark its colour and throw it in a separate container. With replacement you would take out a ball, mark its colour and put it back into the intial bag, meanig it could possibly be recounted. One advantage of sampling with replacement is that your sampling size can be larger than your actual population size. For example, you could create a random sampling of 50 with a bag containing 10 balls with replacement. This would not work without replacement. The below script will cause R to produce an error saying it can be done with replacement. #Randomly sample 5 of these numbers with replacement sample(x = num_vec, size = 5, replace = TRUE) Importantly for us rarefaction uses sampling without replacement. 8.7 Setting a random seed We'll sample, without replacement, the numbers one more time in a new cell. However, this time we will set the random seed with the function seet.seed(). #Set random seed set.seed(1234) #Randomly sample 12 of these numbers without replacement sample(x = num_vec, size = 12, replace = FALSE) #Reset random seed set.seed(NULL) Before we explain the code further, try running the cell multiple times. If it is identical to the above code you will get the numbers \"9, 5, 4, 3, &amp; 6\". How come you are getting these results if it is random? True randomness is pretty much impossible, especially in computing. To get around this many programs use seeds to determine how random tasks will be carried out. Various programs that use random seeds include: Sampling tools such as sample() and rarefaction Creating bootstrapped phylogenies Creating procedural content such as building Minecraft worlds Therefore if you run a tool that will use randomness you will always get the same results if: You use the same random seed You use the same data You use the same replacement method (with or without) In fact, run the below code in a new code cell and you may notice a similarity with your previous output. #Set random seed set.seed(1234) #Create a vector containing the numbers 0 to 10 larger_num_vec &lt;- 10:19 #Randomly sample 5 of these numbers sample(x = num_vec, size = 5) #Reset random seed set.seed(NULL) That's right, sample() will always take the 10th (9/19), 6th (5/15), 5th (4/14), 4th (3/13), and 7th (6/16) values if it is given the random seed of (1234) and provided with a 11 length vector. Setting our randomness is incredible beneficial for reproducibility in research. When you carry out analysis you may need to redo some work. This could be due to reviewer comments or you want to incorporate some new methods. As long as you saved the random seeds you used you can get the same results where you need to. It also means others can replicate your results. 8.8 Reset seed We set a random seed at the start of the cell for reproducibility and control, but why do we then run the line set.seed(NULL)? The normal operation of R means that, in effect, its random seed changes every time it is used. This means R normally randomly determines randomness. This is how it should be until we want to set the randomness. It is therefore good practice to set the seed to NULL after you have utilised your set seeds. This will revert the seed to its normal random operations. One last point to note is R versions. Version 3.6 changed R's sampling methods, therefore if you use Version 3.5 or below you will get different results than we have got. Hopefully the R developers will not change this in a later version again. 8.9 Random seed practice Brilliant! To reinforce the above knowledge try out the following challenges. First create the following vector: second_millenium &lt;- 1001:2000 Note: Remember it is best practice to set.seed(NULL) at the end of a code cell. 8.9.1 Random seed: Question 1 Sample the object second_millenium with the following parameters: Extract 10 values Without replacement Use the random seed 489 What is the fourth number in the produced vector? 1120 1369 1744 8.9.2 Random seed: Question 2 Sample the object second_millenium with the following parameters: Extract 24 values Without replacement Use the answer to the first question as the random seed What is the 16th number in the produced vector? 1120 1369 1744 8.9.3 Random seed: Question 3 Sample the object second_millenium with the following parameters: Extract a number of values equal to the answer of the second question With replacement Use the answer to the first question as the random seed What is the 999th number in the produced vector? 1120 1369 1744 Once you are happy you can save then close and halt your \"Random_seeds.ipynb\" notebook. Hopefully this has given you a good undertstanding of the principle of random seeds. With this you can continue onto iterative rarefaction. "]]
